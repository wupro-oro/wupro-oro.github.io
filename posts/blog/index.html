<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Linux设备树 - BLOG主页</title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="Linux设备树" />
<meta property="og:description" content="Linux设备树 Linux3.x 以后引入了设备树，用于描述一个硬件平台的板级细节。 设备树简介 设备树可以被 bootloader（uboot）传递到内核，内核" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wupro-oro.github.io/posts/blog/" /><meta property="og:image" content="https://wupro-oro.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-12T13:22:02+08:00" />
<meta property="article:modified_time" content="2022-02-12T13:22:02+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://wupro-oro.github.io/logo.png"/>

<meta name="twitter:title" content="Linux设备树"/>
<meta name="twitter:description" content="Linux设备树 Linux3.x 以后引入了设备树，用于描述一个硬件平台的板级细节。 设备树简介 设备树可以被 bootloader（uboot）传递到内核，内核"/>
<meta name="application-name" content="BLOG主页">
<meta name="apple-mobile-web-app-title" content="BLOG主页"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://wupro-oro.github.io/posts/blog/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Linux设备树",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/wupro-oro.github.io\/posts\/blog\/"
        },"genre": "posts","wordcount":  6500 ,
        "url": "https:\/\/wupro-oro.github.io\/posts\/blog\/","datePublished": "2022-02-12T13:22:02+08:00","dateModified": "2022-02-12T13:22:02+08:00","publisher": {
            "@type": "Organization",
            "name": "WuSheng'ao"},"author": {
                "@type": "Person",
                "name": "WuSheng'ao"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="BLOG主页">BLOG主页</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="BLOG主页">BLOG主页</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Linux设备树</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>WuSheng'ao</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-02-12">2022-02-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6500 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 13 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#设备树简介">设备树简介</a></li>
        <li><a href="#设备树框架">设备树框架</a>
          <ul>
            <li><a href="#设备树格式">设备树格式</a>
              <ul>
                <li><a href="#dts-文件布局">DTS 文件布局</a></li>
                <li><a href="#node-格式">node 格式</a></li>
                <li><a href="#properties-格式">properties 格式</a></li>
                <li><a href="#包含-dtsi">包含 dtsi</a></li>
              </ul>
            </li>
            <li><a href="#修改追加设备树节点">修改、追加设备树节点</a></li>
            <li><a href="#常用属性">常用属性</a>
              <ul>
                <li><a href="#常用标准属性">常用标准属性</a></li>
                <li><a href="#自定义属性">自定义属性</a></li>
              </ul>
            </li>
            <li><a href="#常用节点">常用节点</a></li>
          </ul>
        </li>
        <li><a href="#编译更换设备树">编译、更换设备树</a>
          <ul>
            <li><a href="#在内核中编译设备树推荐">在内核中编译设备树(推荐)</a></li>
            <li><a href="#人工编译不推荐">人工编译（不推荐）</a></li>
            <li><a href="#更换设备树">更换设备树</a></li>
            <li><a href="#查看设备树">查看设备树</a></li>
          </ul>
        </li>
        <li><a href="#内核处理设备树">内核处理设备树</a>
          <ul>
            <li><a href="#设备树过程">设备树过程</a></li>
            <li><a href="#转换为-platform_device-的条件">转换为 platform_device 的条件</a></li>
          </ul>
        </li>
        <li><a href="#获取节点函数">获取节点函数</a>
          <ul>
            <li><a href="#重要结构体内容">重要结构体内容</a>
              <ul>
                <li><a href="#device_node">device_node</a></li>
                <li><a href="#of_device_id">of_device_id</a></li>
              </ul>
            </li>
            <li><a href="#据节点路径寻找节点">据节点路径寻找节点</a></li>
            <li><a href="#据节点类型寻找节点">据节点类型寻找节点</a></li>
            <li><a href="#据节点类型和compatible属性寻找节点">据节点类型和compatible属性寻找节点</a></li>
            <li><a href="#据匹配表寻找节点">据匹配表寻找节点</a></li>
            <li><a href="#寻找父节点">寻找父节点</a></li>
            <li><a href="#寻找子节点">寻找子节点</a></li>
          </ul>
        </li>
        <li><a href="#提取节点中的属性值">提取节点中的属性值</a>
          <ul>
            <li><a href="#重要结构体内容-1">重要结构体内容</a>
              <ul>
                <li><a href="#property-结构体">property 结构体</a></li>
                <li><a href="#resource-结构体">resource 结构体</a></li>
              </ul>
            </li>
            <li><a href="#查找节点属性值">查找节点属性值</a></li>
            <li><a href="#获取整型属性">获取整型属性</a></li>
            <li><a href="#简化后的读取整型属性函数">简化后的读取整型属性函数</a></li>
            <li><a href="#读取字符串属性">读取字符串属性</a></li>
            <li><a href="#读取-bool-型属性函数">读取 bool 型属性函数</a></li>
            <li><a href="#内存映射相关-of-函数">内存映射相关 of 函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="linux设备树">Linux设备树</h1>
<p>Linux3.x 以后引入了设备树，用于描述一个硬件平台的板级细节。</p>
<h3 id="设备树简介">设备树简介</h3>
<p>设备树可以被 <strong>bootloader</strong>（uboot）传递到内核，内核从中获取设备树中的硬件信息。</p>
<p><strong>设备树的两个特点</strong>：</p>
<ul>
<li><strong>一</strong>：以 <strong>树状结构</strong> 描述硬件资源。</li>
<li><strong>二</strong>：设备树可以像头文件使用，一个设备树文件引用另外一个设备树文件。</li>
</ul>
<p><strong>几个常用的缩写</strong>：</p>
<ul>
<li><strong>DTS</strong>：是指 <strong>.dts</strong> 格式的文件，是一种 <strong>ASII</strong> 文本格式的设备树描述，也是我们要编写的设备树源码，一般一个 <strong>.dts</strong> 文件对应一个硬件平台，位于 Linux 源码的 <strong>/arch/arm/boot/dts</strong> 目录下。</li>
<li><strong>DTC</strong>：是指编译设备树源码的工具，一般情况下，需要手动安装这个编译工具。</li>
<li><strong>DTB</strong>：是设备树源码编译生成的文件。</li>
<li><strong>.dts</strong>：设备树源文件。</li>
<li><strong>.dtsi</strong>：设备树头文件。</li>
<li><strong>.dtb</strong>：设备树可执行文件。</li>
</ul>
<h3 id="设备树框架">设备树框架</h3>
<p>设备树是由 一个根节点 和 多个子节点 组成。</p>
<h4 id="设备树格式">设备树格式</h4>
<h5 id="dts-文件布局">DTS 文件布局</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">/</span><span class="n">dts</span><span class="o">-</span><span class="n">v1</span><span class="o">/</span><span class="p">;</span> <span class="c1">// 表示版本
</span><span class="c1"></span><span class="p">[</span><span class="n">memory</span> <span class="n">reservations</span><span class="p">]</span> <span class="c1">// 格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;
</span><span class="c1"></span><span class="o">/</span> <span class="p">{</span>
<span class="p">[</span><span class="n">property</span> <span class="n">definitions</span><span class="p">]</span>
<span class="p">[</span><span class="n">child</span> <span class="n">nodes</span><span class="p">]</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="node-格式">node 格式</h5>
<p><strong>node</strong>为设备树中的基本单元。格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="nl">label</span><span class="p">:]</span> <span class="n">node</span><span class="o">-</span><span class="n">name</span><span class="p">[</span><span class="err">@</span><span class="n">unit</span><span class="o">-</span><span class="n">address</span><span class="p">]</span> <span class="p">{</span>
<span class="p">[</span><span class="n">properties</span> <span class="n">definitions</span><span class="p">]</span>
<span class="p">[</span><span class="n">child</span> <span class="n">nodes</span><span class="p">]</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>label</strong>：是节点标签。可以省略，方便地引用 <strong>node</strong>。通常，节点标签通常为基点名称的缩写，一般用于追加内容时使用。</li>
<li><strong>node-name</strong>：节点名称。长度为1-31个字符。可由 <code>0-9 a-z A-Z , . _ + -</code> 组成，且开头只能是大小写字母。
<ul>
<li><strong>注</strong>：根节点没有节点名，使用 <strong><code>/</code></strong> 来表示。</li>
</ul>
</li>
<li><strong>@unit-address</strong>：是单元地址。<strong><code>@</code></strong> 为分隔符。
<ul>
<li><strong>注</strong>：节点中 <strong>reg</strong> 属性的第一个地址要和这个 <strong>单元地址</strong> 一致。</li>
<li><strong>注</strong>：如果节点中没有 <strong>reg</strong> 属性值，则可以省略该 <strong>单元地址</strong>，但此时必须保证同级别的子节点节点名唯一。反之，若同级别的子节点节点名相同，则单元地址要求不一样。就是说 <strong><code>node-name@unit-address</code> 整体同级唯一</strong></li>
</ul>
</li>
</ul>
<h5 id="properties-格式">properties 格式</h5>
<p>就是 <strong>naem = value</strong>。</p>
<ul>
<li>格式1：（<em>没有值</em>）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="nl">label</span><span class="p">:]</span> <span class="n">property</span><span class="o">-</span><span class="n">name</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>格式2：（<em>支持三种取值</em>）
<ul>
<li><strong>arrays of cell</strong>：一个或多个 32 位数据，64 位数据使用 2 个 32 位数据表示。</li>
<li><strong>string</strong>：字符串。</li>
<li><strong>bytestring</strong>：一个或多个字符串。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">[label:] property-name = value
</code></pre></td></tr></table>
</div>
</div><ul>
<li>例子1：64bit 用两个 cell 表示，使用 <strong>尖括号</strong>。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">clock</span><span class="o">-</span><span class="n">frequency</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x00000001</span> <span class="mh">0x00000000</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>例子2：字符串，用 <strong>双引号</strong>。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">compatible</span> <span class="o">=</span> <span class="s">&#34;lzm-bus&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>例子3：字节序列，用 <strong>中括号</strong>。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">local</span><span class="o">-</span><span class="n">mac</span><span class="o">-</span><span class="n">address</span> <span class="o">=</span> <span class="p">[</span><span class="mo">00</span> <span class="mo">00</span> <span class="mi">12</span> <span class="mi">34</span> <span class="mi">56</span> <span class="mi">78</span><span class="p">];</span> <span class="c1">// 每个 byte 使用 2 个 16 进制数来表示
</span><span class="c1"></span><span class="n">local</span><span class="o">-</span><span class="n">mac</span><span class="o">-</span><span class="n">address</span> <span class="o">=</span> <span class="p">[</span><span class="mo">00001234567</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// 每个 byte 使用 2 个 16 进制数来表示
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>例子4：各种组合，用 <strong>逗号</strong> 隔开。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">example</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x84218421</span> <span class="mi">23</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="包含-dtsi">包含 dtsi</h5>
<p>一般设备树都不需要从零开始写，只需要包含芯片厂商提供的设备树模板，然后再添加，修改即可。<br>
<strong>dts</strong> 可以包含 <strong>dtsi</strong> 文件，也可以包含 <strong>.h</strong> 文件。<strong>.h</strong> 文件可以定义一些宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/dts-v1/;
#include &lt;dt-bindings/input/input.h&gt;
#include &#34;imx6ull.dtsi&#34;
/ {
……
}; 
</code></pre></td></tr></table>
</div>
</div><h4 id="修改追加设备树节点">修改、追加设备树节点</h4>
<p>修改、追加设备树节点都可在文件末尾或新文件修改或追加。</p>
<p>而修改节点，可参考以下两种方法：<strong>标签法</strong> 或 <strong>全路径法</strong>：<br>
<strong>标签法</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 方法一：在根节点之外使用标签引用节点
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">red_led</span>
<span class="p">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">&#34;okay&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 方法二：使用全路径引用节点
</span><span class="c1"></span><span class="o">&amp;</span><span class="p">{</span><span class="o">/</span><span class="n">led</span><span class="err">@</span><span class="mh">0x020C406C</span><span class="p">}</span>
<span class="p">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">&#34;okay&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>全路径法</strong>：</p>
<ul>
<li>追加节点，类似新建一个简易的设备树一样。包含根节点到需要新建节点的全路径。</li>
</ul>
<h4 id="常用属性">常用属性</h4>
<p>在节点 <strong>{}</strong> 中包含的内容时节点属性。这些属性信息就是板级硬件描述的信息，驱动会通过内核提供的 API 去获取这些资源信息。</p>
<p><strong>注意</strong>：节点属性可分为 <strong>标准属性</strong> 和 <strong>自定义属性</strong>，即是可以自行添加属性。</p>
<h5 id="常用标准属性">常用标准属性</h5>
<p><strong>compatible</strong> 属性：</p>
<ul>
<li>属性值类型：字符串。双引号。</li>
<li><strong>compatible</strong> 表示兼容。</li>
<li>每一个代表设备的节点都必须有一个 <strong>compatible</strong> 属性值。</li>
<li>由一个或多个字符串组成，使用 &ldquo;<strong>,</strong>&rdquo; 分隔开即可。</li>
<li>如：<strong><code>compatible = &quot;A&quot;, &quot;B&quot;, &quot;C&quot;;</code></strong>。</li>
<li>内核启动时，会按顺序 <strong>A、B、C</strong> 找到对应的驱动程序，与驱动中 <strong>of_match_table</strong> 中的值进行匹配，然后加载对应的驱动。</li>
<li><strong>compatible</strong> 是查找节点的方法之一，还可以通过 <strong>节点名</strong> 或 <strong>节点路径</strong> 找到指定节点。</li>
<li><strong>compatible</strong> 建议格式：&quot;<strong>manufacturer,model</strong>&quot; ，即是 &ldquo;<strong>厂家名，模块名</strong>&quot;。</li>
</ul>
<p><strong>model</strong> 属性：</p>
<ul>
<li>属性值类型：字符串。双引号。</li>
<li><strong>model</strong> 定义硬件是什么。
<ul>
<li>推荐指定设备的制造商和型号，推荐格式 &ldquo;<strong>制造商,型号</strong>&quot;。</li>
</ul>
</li>
<li>如：<strong><code>model = &quot;lzm com,IMX6U-V1&quot;;</code></strong></li>
</ul>
<p><strong>status</strong> 属性：</p>
<ul>
<li>属性值类型：字符串。双引号。</li>
<li><strong>status</strong> 表示当前设备节点状态，用于禁止和启动设备。</li>
<li>有如下值可选：</li>
</ul>
<table>
<thead>
<tr>
<th>value</th>
<th>descripition</th>
</tr>
</thead>
<tbody>
<tr>
<td>okay</td>
<td>设备正常</td>
</tr>
<tr>
<td>disabled</td>
<td>设备不可操作，但后面可以恢复正常</td>
</tr>
<tr>
<td>fail</td>
<td>发生严重错误，需要修复</td>
</tr>
<tr>
<td>fail-sss</td>
<td>发生严重错误，需要修复 sss表示错误信息</td>
</tr>
</tbody>
</table>
<p><strong>#address-cells、#size-cells</strong> 属性：</p>
<ul>
<li>属性值类型：u32。尖括号。</li>
<li><strong>#address-cells、#size-cells</strong> 是同时出现的。
<ul>
<li><strong>#address-cells</strong>：表示 <strong>address</strong> 要用多少个 32 位数来表示。</li>
<li><strong>#size-cells</strong>：表示 <strong>size</strong> 要用多少个 32 位数来表示。</li>
</ul>
</li>
<li>用于设置子节点 <strong>reg、ranges</strong> 等地址相关属性的书写格式。</li>
</ul>
<p><strong>reg</strong> 属性：</p>
<ul>
<li>
<p>属性值类型：地址、长度数据对。尖括号。</p>
</li>
<li>
<p><strong>reg</strong> 就是 <strong>register</strong>，用于表示寄存器地址。</p>
</li>
<li>
<p>用于描述一段内存空间。</p>
</li>
<li>
<p><strong>reg</strong> 属性的值是一些列的</p>
<p>。</p>
<ul>
<li>用多少个 32 位的数来表示是由其父节点的 <strong>#address-cells、#size-cells</strong> 决定的。</li>
</ul>
</li>
<li>
<p>如：</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">/</span><span class="n">dts</span><span class="o">-</span><span class="n">v1</span><span class="o">/</span><span class="p">;</span> 
<span class="o">/</span> <span class="p">{</span> 
    <span class="err">#</span><span class="n">address</span><span class="o">-</span><span class="n">cells</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span> 
    <span class="err">#</span><span class="n">size</span><span class="o">-</span><span class="n">cells</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span> 
    <span class="n">memory</span> <span class="p">{</span> 
        <span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x80000000</span> <span class="mh">0x20000000</span><span class="o">&gt;</span><span class="p">;</span> 
    <span class="p">};</span> 
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p><strong>ranges</strong> 属性：</p>
<ul>
<li>属性值类型：任意数量的 &lt;子地址、父地址、地址长度&gt;编码。尖括号。</li>
<li>该属性提供了子节点地址空间和父地址空间的映射（转换）方法。</li>
<li>如：<strong><code>ranges=&lt;0x05 0x10 0x20&gt;</code></strong></li>
</ul>
<p><strong>name、ldevice_type</strong> 属性：</p>
<ul>
<li>属性值类型：字符串。双引号。</li>
<li><em><strong>过时，不建议使用</strong></em>。</li>
</ul>
<h5 id="自定义属性">自定义属性</h5>
<p>名称及内容可自定义，但是名称不能与标准属性重名。获取方式，后述。</p>
<h4 id="常用节点">常用节点</h4>
<p><strong>根节点</strong>：</p>
<ul>
<li><strong>dts</strong> 文件中必须有一个 <strong>根节点</strong>。</li>
<li><strong>根节点</strong> 必须有以下属性：
<ul>
<li><strong>#address-cells</strong>。</li>
<li><strong>#size-cells</strong>。</li>
<li><strong>compatible</strong>：定义一些列的字符串，用于指定内核中哪个 <strong>machine_desc</strong> 可以支持本设备。即是兼容性。</li>
<li><strong>model</strong>：表示本硬件型号。</li>
</ul>
</li>
</ul>
<p><strong>CPU</strong>：</p>
<ul>
<li>一般都在 <strong>dtsi</strong> 文件中定义好了，不需要我们设置。</li>
</ul>
<p><strong>memory</strong>：</p>
<ul>
<li>这个是表示板子内存大小，一般由开发板开发者定义的。</li>
</ul>
<p><strong>chosen</strong>：</p>
<ul>
<li>该节点主要作用于向内核传递参数。如：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">chosen</span> 
<span class="p">{</span> 
    <span class="n">bootargs</span> <span class="o">=</span> <span class="s">&#34;noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200&#34;</span><span class="p">;</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>aliases</strong>：</p>
<ul>
<li><strong>aliases</strong> 是为了给其它节点起个别名。如：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">aliases</span> <span class="p">{</span>
    <span class="n">can0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flexcan1</span><span class="p">;</span>
    <span class="n">gpio0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>can0</strong> 就是 <strong>flexcan1</strong> 的别名。</li>
</ul>
<h3 id="编译更换设备树">编译、更换设备树</h3>
<p>一般的程序猿会修改设备树即可，不必从零开始。</p>
<h4 id="在内核中编译设备树推荐">在内核中编译设备树(推荐)</h4>
<p>编译时需要设置一下三个环境变量 <strong>ARCH、CROSS_COMPILE、PATH</strong>。</p>
<p>在开发环境中进入板子对应的内核源码目录，使用内核中的 makefile 即可，执行如下命令来编译 <strong>dtb</strong> 文件：</p>
<p>make dtbs V=1</p>
<p>上述命令是单独编译设备树。<br>
<strong>会编译以下设备树</strong>：<br>
在**<code>arch/arm/Makefile 或 arch/arm/boot/Makefile 或 arch/arm/boot/dts/Makefile</code>** 等相关 Makefile 中找到 <strong><code>dtb-$(xxx)</code></strong> ，该值包含的就是要编译的 <strong>dtb</strong> 。<br>
如该文件中宏 <strong>dtb-$(CONFIG_SOC__XXX_)</strong> 包含的 <strong>.dtb</strong> 就会被编译出来。<br>
如果想<strong>编译自己的设备树</strong>，添加该值内容，并把自己的设备树放在 <strong><code>arch/arm/boot/dts</code></strong> 下即可。<br>
（<em><strong>具体查看该 arch/arm/boot/Makefile 内容</strong></em>）</p>
<h4 id="人工编译不推荐">人工编译（不推荐）</h4>
<p>意思是手工使用 <strong>dtc</strong> 工具直接编译。</p>
<p><strong>dtc</strong> 工具存放于内核目录 <strong>scripts/dtc</strong> 下。<br>
若直接使用 <strong>dtc</strong> 工具手工编译的话，包含其它文件时不能使用 <strong><code>#include</code></strong>，而必须使用 <strong><code>/include</code></strong>。</p>
<ul>
<li>因为内核中 <strong>make dtb</strong> 时能使用 <strong><code>#include</code></strong> 是因为使用了 <strong>交叉编译链</strong>。</li>
</ul>
<p>编译、反编译的示例命令如下，<strong>-I</strong> 指定输入格式，<strong>-O</strong> 指定输出格式，<strong>-o</strong> 指定输出文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="p">.</span><span class="o">/</span><span class="n">scripts</span><span class="o">/</span><span class="n">dtc</span><span class="o">/</span><span class="n">dtc</span> <span class="o">-</span><span class="n">I</span> <span class="n">dts</span> <span class="o">-</span><span class="n">O</span> <span class="n">dtb</span> <span class="o">-</span><span class="n">o</span> <span class="n">tmp</span><span class="p">.</span><span class="n">dtb</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">xxx</span><span class="p">.</span><span class="n">dts</span>  <span class="c1">// 编译 dts 为 dtb 
</span><span class="c1"></span><span class="p">.</span><span class="o">/</span><span class="n">scripts</span><span class="o">/</span><span class="n">dtc</span><span class="o">/</span><span class="n">dtc</span> <span class="o">-</span><span class="n">I</span> <span class="n">dtb</span> <span class="o">-</span><span class="n">O</span> <span class="n">dts</span> <span class="o">-</span><span class="n">o</span> <span class="n">tmp</span><span class="p">.</span><span class="n">dts</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">xxx</span><span class="p">.</span><span class="n">dtb</span>  <span class="c1">// 反编译 dtb 为 dts
</span></code></pre></td></tr></table>
</div>
</div><h4 id="更换设备树">更换设备树</h4>
<p>一般步骤：</p>
<ul>
<li>确保好三个环境变量。</li>
<li>在内核源码目录中执行 <strong><code>make dtbs</code></strong> 。</li>
<li>生成的设备树文件一般保存在内核目录 <strong>arch/arm/boot/dts/</strong> 下。</li>
<li>把生成的设备树文件替换到板子上。开发板使用的设备树一般放在 <strong>/boot/</strong> 目录下。</li>
<li>若需要自定义新的设备树文件名称，则修改 <strong>/boot/</strong> 目录下的 <strong>uEnv.txt</strong> 文件内容。</li>
</ul>
<h4 id="查看设备树">查看设备树</h4>
<p>目录 <strong>/sys/firmware/devicetree</strong> 下以目录结构呈现的 <strong>dtb</strong> 文件。</p>
<ul>
<li>根节点对应 <strong>base</strong> 目录。</li>
<li>每一个节点对应一个目录。</li>
<li>每一个属性对应一个文件。
<ul>
<li>若属性值为字符串，则可以使用 <strong>cat</strong> 命令打印出来。</li>
<li>若属性值为数值，则可以使用 <strong>hexdump</strong> 命令打印出来。</li>
</ul>
</li>
</ul>
<p>目录 <strong>/sys/firmware/fdt</strong> 文件，就是 <strong>dtb</strong> 格式的设备树文件。</p>
<ul>
<li>可以将其赋值出来，反编译。</li>
</ul>
<h3 id="内核处理设备树">内核处理设备树</h3>
<h4 id="设备树过程">设备树过程</h4>
<p><strong>设备树生命过程</strong>：<br>
<strong>DTS</strong> &ndash;(<em>PC</em>)&ndash;&gt; <strong>DTB</strong> &ndash;(<em>内核</em>)&ndash;&gt; <strong>device_node</strong> -·(<em>内核</em>)·-&gt; <strong>platform_device</strong>。</p>
<p><strong>流程</strong>：</p>
<ol>
<li><strong>dts</strong> 在 PC 机上被编译为 <strong>dtb</strong> 文件。</li>
<li><strong>u-boot</strong> 把 <strong>dtb</strong> 文件传给内核。</li>
<li>内核解析 <strong>dtb</strong> 文件，把每一个节点都转换为 <strong>device_node</strong> 结构体。</li>
<li>对于某些 <strong>device_node</strong> 结构体，会被转换为 <strong>platform_device</strong> 结构体。</li>
</ol>
<p><em>对于 device_node 和 platform_device，建议去内核源码看看它们的成员。</em></p>
<h4 id="转换为-platform_device-的条件">转换为 platform_device 的条件</h4>
<ul>
<li>根节点下有 <strong>compatile</strong> 属性的子节点。</li>
<li>含有特定 <strong>compatile</strong> 属性的节点的子节点。
<ul>
<li>如果一个节点的 <strong>compatile</strong> 属性是以下 4 个值之一，那么该节点含有 <strong>compatile</strong> 属性的 <strong>子节点</strong>也可以转换为 <strong>platform_device</strong>。
<ul>
<li><strong><code>simple-bus</code></strong>；</li>
<li><strong><code>simple-mfd</code></strong>;</li>
<li><strong><code>isa</code></strong>;</li>
<li><strong><code>arm,amba-bus</code></strong>。</li>
</ul>
</li>
</ul>
</li>
<li>总线 <strong>I2C、SPI</strong> 节点下的子节点 <strong>不转换</strong> 为 <strong>platform_device</strong>。
<ul>
<li>某个总线下的子节点，不应该被转换为 <strong>platform_device</strong>。而应该交给对应的总线驱动来处理。</li>
</ul>
</li>
</ul>
<h3 id="获取节点函数">获取节点函数</h3>
<p>在驱动程序中，内核加载设备树后。可以通过以下函数获取到设备树节点中的资源信息。<br>
获取节点函数及获取节点内容函数称为 <strong>of</strong> 函数。</p>
<h4 id="重要结构体内容">重要结构体内容</h4>
<h5 id="device_node">device_node</h5>
<p><strong>device_node</strong> 结构体如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">device_node</span> 
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="n">phandle</span> <span class="n">phandle</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">full_name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fwnode_handle</span> <span class="n">fwnode</span><span class="p">;</span>
    <span class="k">struct</span>  <span class="n">property</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
    <span class="k">struct</span>  <span class="n">property</span> <span class="o">*</span><span class="n">deadprops</span><span class="p">;</span>    <span class="cm">/* removed properties */</span>
    <span class="k">struct</span>  <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="k">struct</span>  <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
    <span class="k">struct</span>  <span class="n">device_node</span> <span class="o">*</span><span class="n">sibling</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_OF_KOBJ)
</span><span class="cp"></span>    <span class="k">struct</span>  <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_flags</span><span class="p">;</span>
    <span class="kt">void</span>    <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_SPARC)
</span><span class="cp"></span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path_component_name</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unique_id</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">of_irq_controller</span> <span class="o">*</span><span class="n">irq_trans</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>name</strong>：节点中的 <strong>name</strong> 属性值。</li>
<li><strong>type</strong>：节点中的 <strong>device_type</strong> 属性值。</li>
<li><strong>full_name</strong>：节点的名字。</li>
<li><strong>properties</strong>：链表，连接该节点的所有属性。</li>
<li><strong>parent</strong>：指向父节点。</li>
<li><strong>child</strong>：指向子节点。</li>
<li><strong>sibling</strong>：指向兄弟节点。</li>
</ul>
<h5 id="of_device_id">of_device_id</h5>
<p><strong>of_device_id</strong> 结构体如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Struct used for matching a device  */</span>
<span class="k">struct</span> <span class="n">of_device_id</span> 
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">char</span>    <span class="n">type</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">char</span>    <span class="n">compatible</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>name</strong>：节点中属性为 <strong>name</strong> 的值。</li>
<li><strong>type</strong>：节点中属性为 <strong>device_type</strong> 的值。</li>
<li><strong>compatible</strong>：节点的名字，在 <strong>device_node</strong> 结构体后面放一个字符串，<strong>full_name</strong> 指向它。</li>
<li><strong>data</strong>：链表，连接该节点的所有属性。</li>
</ul>
<h4 id="据节点路径寻找节点">据节点路径寻找节点</h4>
<p><strong>of_find_node_by_path()</strong>：</p>
<ul>
<li>函数原型：<strong><code>struct device_node *of_find_node_by_path(const char *path)</code></strong>。</li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>path</strong>：节点在设备树中的路径。</li>
<li>返回值：
<ul>
<li>成功：返回 <strong>device_node</strong> 结构体指针。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
<h4 id="据节点类型寻找节点">据节点类型寻找节点</h4>
<p><strong>of_find_node_by_type()</strong>：</p>
<ul>
<li>函数原型：<strong><code>struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code></strong>。</li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>from</strong>：指定从哪里开始找（<em>不包含本身</em>），若要从根节点开始找，且包含根节点，则该值未 <strong>NULL</strong>。</li>
<li><strong>type</strong>： 要查找节点的类型，这个类型就是 <strong>device_node-&gt;type</strong>。</li>
<li>返回值：
<ul>
<li>成功：返回 <strong>device_node</strong> 结构体指针。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
<h4 id="据节点类型和compatible属性寻找节点">据节点类型和compatible属性寻找节点</h4>
<p><strong>of_find_compatible_node()</strong>：</p>
<ul>
<li>函数原型：<strong><code>struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)</code></strong>。</li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>from</strong>：指定从哪里开始找（<em>不包含本身</em>），若要从根节点开始找，且包含根节点，则该值未 <strong>NULL</strong>。</li>
<li><strong>type</strong>： 要查找节点的类型，这个类型就是 <strong>device_node-&gt;type</strong>。</li>
<li><strong>compatible</strong>：需要查找的节点的 <strong>compatible</strong> 属性。</li>
<li>返回值：
<ul>
<li>成功：返回 <strong>device_node</strong> 结构体指针。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
<h4 id="据匹配表寻找节点">据匹配表寻找节点</h4>
<p><strong>of_find_matching_node_and_match()</strong>：</p>
<ul>
<li>函数原型：<strong><code>struct inline device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</code></strong>。</li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>from</strong>：指定从哪里开始找（<em>不包含本身</em>），若要从根节点开始找，且包含根节点，则该值未 <strong>NULL</strong>。</li>
<li><strong>matches</strong>：<strong>of_device_id</strong> 匹配表，也就是在此匹配表里面查找节点。</li>
<li><strong>match</strong>：找到的匹配的 <strong>of_device_id</strong>。</li>
<li>返回值：
<ul>
<li>成功：返回 <strong>device_node</strong> 结构体指针。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
<h4 id="寻找父节点">寻找父节点</h4>
<p><strong>of_get_parent()</strong>：</p>
<ul>
<li>函数原型：<strong><code>struct device_node *of_get_parent(const struct device_node *node)</code></strong>。</li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>node</strong>：需要查找要查找父节点的节点。</li>
<li>返回值：
<ul>
<li>成功：返回 <strong>device_node</strong> 结构体指针。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
<h4 id="寻找子节点">寻找子节点</h4>
<p><strong>of_get_child()</strong>：</p>
<ul>
<li>函数原型：<strong><code>struct device_node *of_get_child(const struct device_node *node, struct device_node *prev)</code></strong>。</li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>node</strong>：需要查找要查找子节点的节点。</li>
<li><strong>prev</strong>：需要寻找的节点的前一个节点，即是本函数需要寻找 <strong>prev</strong> 节点的后一个节点。</li>
<li>返回值：
<ul>
<li>成功：返回 <strong>device_node</strong> 结构体指针。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
<h3 id="提取节点中的属性值">提取节点中的属性值</h3>
<h4 id="重要结构体内容-1">重要结构体内容</h4>
<h5 id="property-结构体">property 结构体</h5>
<p><strong>property</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">property</span> 
<span class="p">{</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span>     <span class="n">length</span><span class="p">;</span>
    <span class="kt">void</span>    <span class="o">*</span><span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)
</span><span class="cp"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_flags</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp">#if defined(CONFIG_OF_PROMTREE)
</span><span class="cp"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unique_id</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp">#if defined(CONFIG_OF_KOBJ)
</span><span class="cp"></span>    <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">attr</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>name</strong>：属性名。</li>
<li><strong>lenght</strong>：属性长度。</li>
<li><strong>value</strong>：属性值。</li>
<li><strong>next</strong>：下一个属性。</li>
</ul>
<h5 id="resource-结构体">resource 结构体</h5>
<p><strong>resource</strong> 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">resource</span> 
<span class="p">{</span>
    <span class="n">resource_size_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">resource_size_t</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">desc</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">sibling</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="查找节点属性值">查找节点属性值</h4>
<p><strong>of_find_property()</strong>：</p>
<ul>
<li>
<p>函数原型：<strong><code>struct property *of_find_property(const struct device_node *np,const char *name,int *lenp)</code></strong></p>
</li>
<li>
<p>源码路径：<strong>内核源码/include/linux/of.h</strong>。</p>
</li>
<li>
<p><strong>np</strong>：设备节点。</p>
</li>
<li>
<p><strong>name</strong>：属性名称。</p>
</li>
<li>
<p><strong>lenp</strong>：实际获得属性值的长度（<em>函数输出参数</em>）。</p>
</li>
<li>
<p>返回值：</p>
<ul>
<li>成功：返回 <strong>property</strong> 结构体，获取得到的属性。</li>
<li>失败：返回 NULL。</li>
</ul>
</li>
<li>
<p>可以了解下 获取属性值函数 <strong>of_get_property()</strong> ，与 <strong>of_find_property()</strong> 的区别是一个返回属性值，一个返回属性结构体。</p>
</li>
</ul>
<h4 id="获取整型属性">获取整型属性</h4>
<p><strong>of_property_read_u8_array</strong>：</p>
<ul>
<li>以下函数分别读取 8、16、32、64 位数据：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="c1">//8位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u8_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="c1">//16位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u16_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="c1">//32位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u32_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="c1">//64位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u64_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>np</strong>：指定设备节点。</li>
<li><strong>propname</strong>：哪个属性。</li>
<li><strong>out_values</strong>：保存读取到的数据（<em>函数输出参数</em>）。</li>
<li><strong>sz</strong>：设置读取的长度。</li>
<li>返回值：
<ul>
<li><strong>成功</strong>：0.</li>
<li><strong>失败</strong>：非零值
<ul>
<li><strong>-EINVAL</strong>：属性不存在。</li>
<li><strong>-ENODATA</strong>：没有要读取的数据。</li>
<li><strong>-EOVERFLOW</strong>：属性值列表太小。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="简化后的读取整型属性函数">简化后的读取整型属性函数</h4>
<p><strong>of_property_read_u8</strong>：</p>
<ul>
<li>其读取长度为 1。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//8位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u8</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span><span class="n">u8</span> <span class="o">*</span><span class="n">out_values</span><span class="p">)</span>
<span class="c1">//16位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u16</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span><span class="n">u16</span> <span class="o">*</span><span class="n">out_values</span><span class="p">)</span>
<span class="c1">//32位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u32</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span><span class="n">u32</span> <span class="o">*</span><span class="n">out_values</span><span class="p">)</span>
<span class="c1">//64位整数读取函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">of_property_read_u64</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span><span class="n">u64</span> <span class="o">*</span><span class="n">out_values</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><h4 id="读取字符串属性">读取字符串属性</h4>
<p><strong>of_property_read_string_index</strong>：（<em>推荐</em>）</p>
<ul>
<li>函数原型：<strong><code>int of_property_read_string_index(const struct device_node *np,const char *propname, int index, const char **out_string)</code></strong></li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>np</strong>：指定设备节点。</li>
<li><strong>propname</strong>：哪个属性。</li>
<li><strong>index</strong>：指定要读取该属性值得第几个字符串。<strong>index</strong> 从 0 开始。</li>
<li><strong>out_string</strong>：获取到的字符串的指针（<em>函数输出参数</em>）。</li>
<li>返回：
<ul>
<li>成功：0；</li>
<li>失败：失败错误码。</li>
</ul>
</li>
</ul>
<p><strong>of_property_read_string</strong>：（<em>不推荐</em>）</p>
<ul>
<li>函数原型：<strong><code>int of_property_read_string(const struct device_node *np,const char *propname,const char **out_string)</code></strong></li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li>参数同上。</li>
</ul>
<h4 id="读取-bool-型属性函数">读取 bool 型属性函数</h4>
<p><strong>of_property_read_bool()</strong>：</p>
<ul>
<li>函数原型：<strong><code>static inline bool of_property_read_bool(const struct device_node *np, const char *propname)</code></strong></li>
<li><strong>np</strong>：设备节点。</li>
<li><strong>propname</strong>：属性名称。</li>
<li>返回值：只返回该属性存不存在。</li>
<li>若要读取该属性值，需要用到函数 <strong>of_find_property</strong>。</li>
</ul>
<h4 id="内存映射相关-of-函数">内存映射相关 of 函数</h4>
<p>设备树提供寄存器的地址段，但是一般情况下都会使用 <strong>ioremap</strong> 映射为虚拟地址使用。<br>
<strong>of_address_to_resource</strong> 只是获取 <strong>reg</strong> 的值，也就是寄存器值。<br>
<strong>of_iomap</strong> 函数就是获取 <strong>reg</strong> 属性值&amp;指定哪一段内存&amp;映射为虚拟地址。</p>
<p><strong>of_address_to_resource</strong>：</p>
<ul>
<li>函数原型：<strong><code>int of_address_to_resource(struct device_node *dev, int index, struct resource *r)</code></strong></li>
<li>源码路径：<strong><code>内核源码/drivers/of/address.c</code></strong>。</li>
<li><strong>np</strong>：设备节点。</li>
<li><strong>index</strong>：指定映射那一段内存。通常情况下，<strong>reg</strong> 属性包含多段。标号从 0 开始。</li>
<li><strong>r</strong>：<strong>resource</strong> 结构体，得到的地址信息（<em>函数输出参数</em>）。</li>
<li>返回：
<ul>
<li>成功：0；</li>
<li>失败：失败错误码。</li>
</ul>
</li>
</ul>
<p><strong>of_iomap</strong>：</p>
<ul>
<li>函数原型：<strong><code>void __iomem *of_iomap(struct device_node *np, int index)</code></strong></li>
<li>源码路径：<strong>内核源码/include/linux/of.h</strong>。</li>
<li><strong>np</strong>：设备节点。</li>
<li><strong>index</strong>：指定映射那一段内存。通常情况下，<strong>reg</strong> 属性包含多段。标号从 0 开始。</li>
<li>返回：
<ul>
<li>成功：转换后的地址。</li>
<li>失败：NULL。</li>
</ul>
</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-02-12</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.91.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">WuSheng&#39;ao</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
